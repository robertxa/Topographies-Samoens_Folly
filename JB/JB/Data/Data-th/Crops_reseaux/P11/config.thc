encoding  utf-8

# Copyright (C) 2019 Xavier Robert <xavier.robert01@gmail.com>
# This work is under the Creative Commons Attribution-ShareAlike-NonCommecial License:
#	<http://creativecommons.org/licenses/by-nc-sa/4.0/> 

# File to set up specific settings for Therion drawing outputs
# In your *.thconfig file, you need to call this file with:
#    input <path/to/the/file/>config.thc
# and then, in each layout, you need to call the corresponding layout:
#    copy drawingconfig


# change the name for the legend
text en "line u:rope" "rope" #text to appear in legend
text fr "line u:rope" "corde" #text to appear in legend 
text en "line u:fault" "fault" #text to appear in legend
text fr "line u:fault" "faille" #text to appear in legend 
text en "line u:strata" "strata" #text to appear in legend
text fr "line u:strata" "strate" #text to appear in legend 
  
layout drawingconfig
# Layout to draw the map and extended view.
  
  # Set the language
	language fr
  # Set the symology you want to use: UIS, ASF (Australie) CCNP (Etats Units) ou
  # SKB (tchecoslovakia) 
	#symbol-set UIS
  # Change the type or colors of symbols:
	symbol-assign point station:temporary SKBB
	symbol-color point water-flow [0 0 100]
	symbol-color line water-flow [0 0 100]
	symbol-color point ice [0 0 100]
	symbol-color line wall:ice [0 0 100]
	symbol-color point ice-pillar [0 0 100]
	symbol-color area ice [0 0 100]
	symbol-color point snow [0 0 100]
	symbol-color point spring [0 0 100]
	symbol-color point root [0 100 0]
	symbol-color point vegetable-debris [0 100 0]
	symbol-color point altitude [100 50 0]
	 
	
####### Metapost-changes ############
  
code metapost

	# to change blocs size	
	def a_blocks (expr p) =
		T:=identity;
		pickup PenC;
		path q, qq; q = bbox p;
		picture tmp_pic; 
		uu := max(u, (xpart urcorner q - xpart llcorner q)/100, (ypart urcorner q - ypart     llcorner q)/100);
		tmp_pic := image(
		for i = xpart llcorner q step 1.0uu until xpart urcorner q:
			for j = ypart llcorner q step 1.0uu until ypart urcorner q:
				qq := punked (((-.3uu,-.3uu)--(.3uu,-.3uu)--(.3uu,.3uu)--(-.3uu,.3uu)--cycle) 
				randomized (uu/2))
					rotated uniformdeviate(360)
					shifted ((i,j) randomized 1.0uu);
				if xpart (p intersectiontimes qq) < 0:
					thclean qq;
					thdraw qq;
				fi;
			endfor;  
		endfor;
		);
		clip tmp_pic to p;
		draw tmp_pic;
	enddef;
  
 	#  To change sand aspects
 	def a_sands (expr p) =
		T:=identity;
		pickup PenC;
		path q; q = bbox p;
		picture tmp_pic;
		tmp_pic := image(
		for i = xpart llcorner q step 0.1u until xpart urcorner q:
			for j = ypart llcorner q step 0.1u until ypart urcorner q:
				draw origin shifted ((i,j) randomized 0.1u) withpen PenC;
			endfor;
		endfor;
		);
		#clip tmp_pic to p;
		draw tmp_pic;
	enddef;
  
 	# To change pebbles aspects
 	def a_pebbles_SKBB (expr p) =
		T:=identity;
		pickup PenC;
		path q, qq; q = bbox p;
		picture tmp_pic; 
		tmp_pic := image(
		for i = xpart llcorner q step .1u until xpart urcorner q:
			for j = ypart llcorner q step .5u until ypart urcorner q:
				qq := (superellipse((.07u,0),(0,.03u), (-.07u,0),(0,.-.03u),.75))
				%randomized (u/25)
				rotated uniformdeviate(360) 
				shifted ((i,j) randomized 0.27u);
				if xpart (p intersectiontimes qq) < 0:
					thdraw qq;
				fi;
			endfor;  
		endfor;
		);
		clip tmp_pic to p;
		draw tmp_pic;
	enddef;
  
	 # To change slopes aspects
	def l_slope (expr P,S)(text Q) = 
		%show Q;
		T:=identity;
		numeric dirs[];
		numeric lengths[];
		for i=Q:
			dirs[redpart i]:=greenpart i;
			lengths[redpart i]:=bluepart i;
		endfor;  
		li:=length(P); % last
		alw_perpendicular:=true;
		for i=0 upto li:
		if unknown dirs[i]: dirs[i]:=-1; 
		else: 
			if dirs[i]>-1:
				dirs[i]:=((90-dirs[i]) - angle(thdir(P,i))) mod 360;
				alw_perpendicular:=false;
			fi;
		fi;
		if unknown lengths[i]: lengths[i]:=-1; fi;
		endfor;
		%for i=0 upto li: show dirs[i]; endfor;
		ni:=0; % next
		pi:=0; % previous
		for i=0 upto li:
			d:=dirs[i];
			if d=-1:
				if (i=0) or (i=li):
					dirs[i] := angle(thdir(P,i) rotated 90) mod 360;
					pi:=i;
				else:
					if ni<=i:
						for j=i upto li:
							ni:=j;
							exitif dirs[j]>-1;
						endfor;
					fi;
					w:=arclength(subpath(pi,i) of P) / 
					arclength(subpath(pi,ni) of P);
					dirs[i]:=w[dirs[pi],dirs[ni]];
					%if (dirs[i]-angle(thdir(P,i))) mod 360>180:
					%dirs[i]:=w[dirs[ni],dirs[pi]];
					%message("*******");
					%fi;
				fi;
			else:
				pi:=i;
			fi;
		endfor;
		%for i=0 upto li: show dirs[i]; endfor;
		ni:=0; % next
		pi:=0; % previous
		for i=0 upto li:
			l:=lengths[i];
			if l=-1:
				if (i=0) or (i=li):
					lengths[i] := 1cm; % should never happen!
					thwarning("slope width at the end point not specified");
					pi:=i;
				else:
					if ni<=i:
						for j=i+1 upto li:
							ni:=j;
							exitif lengths[j]>-1;
						endfor;  
					fi;
					w:=arclength(subpath(pi,i) of P) /   
					arclength(subpath(pi,ni) of P);
					lengths[i]:=w[lengths[pi],lengths[ni]];
					pi:=i;
				fi;
			else:
				pi:=i;
			fi;
		endfor;
		%for i=0 upto li: show lengths[i]; endfor;
		T:=identity;
		boolean par;
		cas := 0.3u;
		krok := 0.7u;
		dlzka := (arclength P);
		if dlzka>3u: dlzka:=dlzka-0.6u fi;
		mojkrok:=adjust_step(dlzka,1.4u) / 5;
		pickup PenD;
		par := false;
		forever:
			t := arctime cas of P;
			if t mod 1>0:  % not a key point
				w := (arclength(subpath(floor t,t) of P) / 
				arclength(subpath(floor t,ceiling t) of P));
				if alw_perpendicular:
					a := 90;
				else:
					a := w[dirs[floor t],dirs[ceiling t]];
				fi;
				l := w[lengths[floor t],lengths[ceiling t]];
			else:
				if alw_perpendicular:
					a := 90;
				else:
					a:= dirs[t];
				fi; 
				l:=lengths[t];
			fi;    
			a := a + angle(thdir(P,t));    
			thdraw (point t of P) -- 
			((point t of P) + if par: 0.333 * fi l * unitvector(dir(a)));
			cas := cas + mojkrok;
			par := not par;
			exitif cas > dlzka + .3u + (krok / 3);  % for rounding errors
		endfor;
		if S = 1: pickup PenC; draw P fi;
			%pickup pencircle scaled 3pt;
			%for i=0 upto li: draw point i of P; endfor;
	enddef; 

	# To change color of Sump
	def a_sump (expr p) =
		T:=identity;
		thfill p withcolor (0.0, 0.0, 0.3);
	enddef;
  
	# To change color of Water area    
	def a_water (expr p) =
		T:=identity;
		thfill p withcolor (0.0, 0.0, 0.1);
	enddef;
  
	# Northarrow more funnier !
	def s_northarrow (expr rot) =
		begingroup
			interim defaultscale:=0.7; % scale your north arrow here
			T:=identity scaled defaultscale rotated -rot;
			interim linecap:=squared;
			interim linejoin:=rounded;
			thfill (-.5cm,-.1cm)--(0,2.5cm)--(.5cm,-.1cm)--cycle;
			pickup pencircle scaled (0.08cm * defaultscale);
			thdraw (0,0)--(0,-2.5cm);
			pickup pencircle scaled (0.16cm * defaultscale);
			p:=(0.4cm,0.6cm);
			thdraw ((p--(p yscaled -1)--(p xscaled -1)--(p scaled -1)) shifted (0,-1.0cm));
			label.rt(thTEX("mg") scaled 1.6, (.6cm,-1.6cm)) transformed T;
		endgroup;
	enddef; 
  
 	# Change Scale bar type
	def s_scalebar (expr l, units, txt) =
		begingroup
			interim warningcheck:=0;
			tmpl:=l / Scale * cm * units / 2;
			tmpx:=l / Scale * cm * units / 5;
			tmph:=5bp; % bar height
		endgroup;
		pickup PenC;
		draw (-tmpl,0)--(tmpl,0)--(tmpl,-tmph)--(-tmpl,-tmph)--cycle;
		p:=(0,0)--(tmpx,0)--(tmpx,-tmph)--(0,-tmph)--cycle;
		for i:=-2.5 step 2 until 2:
			fill p shifted (i * tmpx,0);
		endfor;
		begingroup
			interim labeloffset:=3.5bp;
			for i:=0 step (l/5) until (l-1):
				tmpx:=tmpl * (i * 2 / l - 1);
				label.bot(thTEX(decimal (i)),(tmpx,-tmph));
			endfor;
			label.bot(thTEX(decimal (l) & "\thinspace" & txt),(tmpl,-tmph));
			% To write the scale "1:scale"; Comment it ?
			%label.top(thTEX("Echelle 1 : " & decimal (Scale*100)),(0,0));
		endgroup;
	enddef; 
   
   # Change the altitude definition
   #     This label requires to specify the position of text relative to point with 
   #     help of -align in the options box. 
   #     ex: -align bottom-right/top-left/top-right/bottom-left/top/bottom/left/right...
	def p_altitude (expr pos) =
		T:=identity shifted pos;
		pickup PenD;
		p:=(-.3u,0)--(.3u,0);
		thdraw p; thdraw p rotated 90;
		p:=fullcircle scaled .2u;
		thclean p; thdraw p;
	enddef;
	vardef p_label@#(expr txt,pos,rot,mode) =
		if mode=1:
			thdrawoptions(withcolor .8red + .4blue);
			p_altitude(pos);
			% append "m" to label
			picture txtm;
			txtm:=image(
				draw txt;
				interim labeloffset:=0;
				label.urt(btex \thaltitude m etex, lrcorner txt);
			);
			% give extra offset in case of l/r/t/b alignment
			pair ctmp;
			ctmp:=center thelabel@#("x", (0,0));
			if (xpart ctmp * ypart ctmp)=0:
				interim labeloffset:=(.4u);
			else: % diagonal alignment
				interim labeloffset:=(.2u);
			fi;
			% draw label
			lab:=thelabel@#(txtm, pos);
			draw lab _thop_; % use color
			thdrawoptions();
			bboxmargin:=0.8bp;
			write_circ_bbox((bbox lab) smoothed 2);
		else:
			if mode=7: interim labeloffset:=(u/8) fi;
			lab:=thelabel@#(txt, pos);
			if mode>1: pickup PenD fi;
			if mode=2: process_uplabel;
			elseif mode=3: process_downlabel;
			elseif mode=4: process_updownlabel;
			elseif mode=5: process_circledlabel;
			elseif mode=6: process_boxedlabel;
			elseif mode=7: process_label(pos,rot);  % station name
			elseif mode=8: process_filledlabel(pos, rot);
			else: process_label(pos,rot); fi;
    	fi;
  	enddef;
  
  # For point height with P or C prefixe 
  # use “point 0 0 height -value [+10 m]” 
  # or “point 0 0 height -value [-85 m]” 
  # in your data to get E10 or P85
     verbatimtex \def\thheightpos{E}\def\thheightneg{P} etex 

  # definition of new lines/symbols
	
	#    Line symbol for strata for cross sections. It works exactly as line section 
	#    symbol but you should use -clip off option:
	def l_u_strata (expr P) =
		T:=identity;
		path Q; Q = punked P;
		for t = 0 upto length P - 1:
			pair zz[];
			zz1 := point t of P;
			zz2 := point t+1 of P;
			zz3 := postcontrol t of P;
			zz4 := precontrol t+1 of P;
			linecap:=0;
			if (length(zz3-1/3[zz1,zz2]) > 0.1pt) or (length(zz4-2/3[zz1,zz2]) > 0.1pt):
				zz5 = whatever[zz1,zz2];
				(zz3-zz5) = whatever * (zz1-zz2) rotated 90;
				pickup pencircle scaled 1 mm;
				draw zz1--zz5 dashed evenly;
				pickup PenA;
				draw zz1--zz5 withcolor background;
				zz6 = whatever[zz1,zz2];
				(zz4-zz6) = whatever * (zz1-zz2) rotated 90;
				pickup pencircle scaled 1 mm;
				draw zz2--zz6 dashed evenly;
				pickup PenA;
				draw zz2--zz6 withcolor background;
			else:
				pickup pencircle scaled 1 mm;
				draw zz1--zz2 dashed evenly;
				pickup PenA;
				draw zz1--zz2 withcolor background;
			fi;
		endfor;
	enddef;

	# Line symbol for fault. It works exactly as line section symbol but you should use -clip off option:
	def l_u_fault (expr P) =
		T:=identity;
		path Q; Q = punked P;
		pickup PenA;
		for t = 0 upto length P - 1:
			pair zz[];
			zz1 := point t of P;
			zz2 := point t+1 of P;
			zz3 := postcontrol t of P;
			zz4 := precontrol t+1 of P;
			if (length(zz3-1/3[zz1,zz2]) > 0.1pt) or (length(zz4-2/3[zz1,zz2]) > 0.1pt):
				zz5 = whatever[zz1,zz2];
				(zz3-zz5) = whatever * (zz1-zz2) rotated 90;
				draw zz1--zz5 dashed evenly;
				zz6 = whatever[zz1,zz2];
				(zz4-zz6) = whatever * (zz1-zz2) rotated 90;
				draw zz2--zz6 dashed evenly;
			else:
				draw zz1--zz2 dashed evenly;
			fi;
		endfor;
	enddef;

	# code to define a doline
	def l_u_doline (expr P) =
		T:=identity;
		laenge:= arclength P;
		symsize:=adjust_step(laenge,2u);
		triangle_width:=symsize/10;
		cur:=(symsize-triangle_width)/2;
		pickup PenC;
		forever:
			t1 := arctime (cur) of P;
			t  := arctime (cur + triangle_width/2) of P;
			t2 := arctime (cur + triangle_width) of P;
			thfill (subpath (t1,t2) of P) -- 
			((point t of P) + symsize/2 * unitvector(thdir(P,t) rotated 90)) -- 
			cycle;
			thdraw (point t2 of P) --((point t of P) + symsize/2 * unitvector(thdir(P,t) rotated 90)) -- 
			(point t1 of P) withcolor (0.5, 0, 0);
			cur := cur + symsize;
			exitif cur > laenge - (1*symsize/3); % for rounding errors
			t1:=arctime (cur) of P;
		endfor;
	enddef;

	# Modifier l aspect et les données des statistiques de longueur affichees
	#code tex-map
	#	\cavelength{1330\thinspace{}m} 
	#	+ 150\thinspace{}m estimes}
	#	\cavedepth{243\thinspace{}m}
	
endcode
  
endlayout 


layout layoutmapborder  
# If you want to draw a frame around the map
	code tex-map
		\framethickness=0.5mm
endlayout


#CODE TO CUSTOMISE ATLAS OUTPUT
#------------------------------
layout LayoutAtlasNorthArrow
#This code is a redefinition of the default atlas definition
#that includes both north arrow & scale bar beside the navigation pane

code tex-atlas
	\def\dopage{%
		\vbox{\centerline{\framed{\mapbox}}
			\bigskip
			\line{%
				\vbox to \ht\navbox{
					\hbox{\size[20]\the\pagelabel
					\ifpagenumbering\space(\the\pagenum)\fi
					\space\size[16]\the\pagename}
					\ifpagenumbering
						\medskip
						\hbox{\qquad\qquad
							\vtop{%
								\hbox to 0pt{\hss\showpointer\pointerN\hss}
								\hbox to 0pt{\llap{\showpointer\pointerW\hskip0.7em}%
								\raise1pt\hbox to 0pt{\hss$\updownarrow$\hss}%
								\raise1pt\hbox to 0pt{\hss$\leftrightarrow$\hss}%
								\rlap{\hskip0.7em\showpointer\pointerE}}
								\hbox to 0pt{\hss\showpointer\pointerS\hss}
							}\qquad\qquad
							\vtop{
								\def\arr{$\uparrow$}
								\showpointerlist\pointerU
								\def\arr{$\downarrow$}
								\showpointerlist\pointerD
							}
						}
					\fi
					\vss
				}
				\hss
				\vbox to \ht\navbox{
					\ifnortharrow\hbox to 0pt{\hss\northarrow\qquad}\fi
					\vss
					\ifscalebar\hbox to 0pt{\hss\scalebar\qquad}\fi
				}
				\box\navbox
			}
		}
	}

endlayout LayoutAtlasNorthArrow